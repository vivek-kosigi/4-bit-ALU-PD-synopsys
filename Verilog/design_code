Design code :

`timescale 1ns / 1ps
module ALU_4bit (
    input  [3:0] A,       // 4-bit input A
    input  [3:0] B,       // 4-bit input B
    input  [3:0] ALU_Sel, // 4-bit ALU operation selector
    output reg [3:0] ALU_Out, // 4-bit ALU result
    output reg CarryOut   // Carry output
);

always @(*) begin
    CarryOut = 0; // Default carry output
    case (ALU_Sel)
        4'b0000: {CarryOut, ALU_Out} = A + B;     // Addition
        4'b0001: {CarryOut, ALU_Out} = A - B;     // Subtraction
        4'b0010: ALU_Out = A & B;                  // AND
        4'b0011: ALU_Out = A | B;                  // OR
        4'b0100: ALU_Out = A ^ B;                  // XOR
        4'b0101: ALU_Out = ~(A & B);               // NAND
        4'b0110: ALU_Out = ~(A | B);               // NOR
        4'b0111: ALU_Out = (A < B) ? 4'b0001 : 4'b0000;  // Less than comparison
        4'b1000: ALU_Out = A * B;                   // Multiplication (lower 4 bits)
        4'b1001: ALU_Out = (B != 0) ? (A / B) : 4'b0000; // Division with zero check
        default: ALU_Out = 4'b0000;
    endcase
end

endmodule
